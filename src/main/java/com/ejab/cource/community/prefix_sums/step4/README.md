# Разностный массив; прибавление констант, арифметических прогрессий и квадратичных функций на отрезке
Мы уже научились по массиву строить его массив префиксных сумм. А теперь давате научимся по массиву префиксных сумм строить исходный массив, то есть применять обратную операцию.
### Определение

**Разностным массивом** массива $[b_0, b_1, \ldots, b_{n - 1}]$ называется массив $[a_0, a_1, \ldots, a_{n - 2}]$, определяющийся следующим образом:

$a_0 = b_1 - b_0$

$a_1 = b_2 - b_1$

$a_2 = b_3 - b_2$

$\ldots$

$a_{n - 3} = b_{n - 2} - b_{n - 3}$

$a_{n - 2} = b_{n - 1} - b_{n - 2}$

Очевидно, что если $b$ — массив префиксных сумм массива $a$, то массив $a$ — разностный массив массива $b$, потому что формула $a_i = b_{i + 1} - b_i$ — это просто преобразованная рекуррентная формула для поиска префиксных сумм: $b_{i + 1} = b_i + a_i$. Однако разностный массив может помочь нам даже там, где массивом префиксных сумм и не пахнет! Также обратите внимание, что если для подсчета массива префиксных сумм была нужна рекуррентная формула, то каждый член разностного массива зависит всего от двух элементов исходного, так что можно пользоваться формулами из определения для подсчета разностного массива за $O(n)$.
```cpp
vector<int> findDiffsArray(vector<int>& arr) {
    int n = arr.size();
    vector<int> diffs(n - 1);
    for (int i = 0; i < n - 1; i++) {
        diffs[i] = arr[i + 1] - arr[i];
    }
    return diffs;
}
```
Если вы знакомы с основами матанализа, можно заметить, что переход к разностному массиву — это дискретное дифференцирование, а переход к массиву префиксных сумм — дискретное интегрирование.

### Применения разностного массива

Решим несколько задач, используя разностный массив. Мы уже решили задачу нахождения суммы на отрезке при помощи префиксных сумм, а теперь рассмотрив в некотором смысле обратную задачу: задачу о прибавлении на отрезке.

### Задача

Дан массив длины $n$. Приходят $q$ запросов: прибавить на полуинтервале $[l, r)$ ко всем элементам число $d$. После выполнения всех запросов необходимо вывести получившийся массив. Асимптотика $O(n + q)$.

### Решение

Ранее мы говорили о том, что если элементы массива меняются, то для решения задачи понадобятся продвинутые структуры, такие как дерево отрезков или дерево Фенвика. Однако здесь мы обойдемся без них, потому что у нас есть только запросы изменения, а запрос «получения» есть только один в самом конце.

Давайте в начало исходного массива $b$ допишем фиктивный элемент ноль и у получившегося массива возьмем разностный массив $a$. После чего будем наблюдать за тем, как этот массив $a$ будет меняться в следствии запросов изменения массива $b$ на отрезке. Фиктивный ноль мы добавили для того, чтобы не потерять информацию о нулевом элементе массива $b$, ведь только по разностям соседних элементов восстановить исходный массив не получится.

Пускай на полуинтервале $[l, r)$ исходного массива (или на полуинтервале $[l + 1, r + 1)$ массива с фиктивным нулем в начале) прибавили ко всем элементам $d$. Заметим, что элементы массива $a$ на позициях меньших $l$ и больших $r$ никак не поменяются, потому что оба элемента в разности никак не поменялись. На позициях $l + 1, \ldots, r - 1$ тоже ничего не поменяется, потому что к обоим элементам разности прибавят $d$, в результате чего сама разность не изменится. К примеру, для позиции $l + 1$:

$$b^{new}_{l + 1} - b^{new}_{l} = \left(b^{old}_{l + 1} + d\right) - \left(b^{old}_l + d\right) = b^{old}_{l + 1} + d - b^{old}_l - d = b^{old}_{l + 1} - b^{old}_l$$

Таким образом, после операции прибавления на отрезке изменятся только два элемента разностного массива: $a_{l}$ заменится на $a_{l} + d$, и $a_r$ заменится на $a_r - d$.

Алгоритм получается следующий: изначально перейдем от исходного массива к его разностному массиву, предварительно добавив в начало массива $0$, чтобы не потерять информацию о $b_0$. Затем выполняем операции изменения за $O(1)$ каждую, потому что нужно поменять каждый раз всего два элемента. И в конце нужно вернуться к исходному виду массива, посчитав префиксные суммы.
```cpp
vector<int> precalc(vector<int> b) {
    b.insert(b.begin(), 0); // add leading zero
    vector<int> a = findDiffsArray(b);
    return a;
}

void addOnHalfInterval(int l, int r, int d) { // [l, r) += d
    a[l] += d;
    if (r < n) {
        a[r] -= d;
    }
}

vector<int> postcalc(vector<int>& a) {
    vector<int> finalB = findPrefixSums(a);
    finalB.erase(finalB.begin()); // delete leading zero
    return finalB;
}
```
Обратите внимание на то, что если $r = n$, то такого элемента нет в массиве $a$, ведь этот элемент отвечал бы за разность элемента после конца массива $b$ с последним элементом массива $b$, которая нас не интересует. Поэтому в таком случае мы ничего не делаем.

На самом деле можно было даже не брать разностный массив. Можно было считать, что изначально массив состоял из всех нулей, тогда его разностный массив тоже состоит из всех нулей; на этом массиве произвести все операции, посчитать массив префиксных сумм и уже в самом конце прибавить начальные значения элементов массива.

### Задача

Дан массив длины $n$. Приходят $q$ запросов: прибавить на полуинтервале $[l, r)$ арифметическую програссию с шагом $step$, то есть к элементу на позиции $l$ прибавить $step$, к элементу на позиции $l + 1$ прибавить $2 \cdot step$, к элементу на позиции $l + 2$ прибавить $3 \cdot step$, ..., и наконец к элементу на позиции $r - 1$ прибавить $\left(r - l\right) \cdot step$.

После выполнения всех запросов необходимо вывести получившийся массив. Асимптотика $O(n + q)$.

### Решение

Задача похожа на предыдущую, но явно сложнее, ведь к каждому элементу на отрезке прибавляется разное число. Давайте посмотрим, что произойдет, если мы как и раньше перейдем к разностному массиву. Заметим, что если мы на полуинтервале прибавили $step, 2 \cdot step, \ldots, (r - l) \cdot step$, то в разностном массиве мы на некотором полуинтервале прибавим ко всем элементам $step$, а также из элемента на правой границе вычтется $(r - l) \cdot step$. Но ведь прибавлять число на отрезке мы уже умеем! Давайте перейдем к разностному массиву разностного массива, при этом не забыв в таком случае добавить уже не один, а два фиктивных нуля в начало массива. Тогда для разностного массива разностного массива изменятся только элементы на позициях $l$, $r$ и $r + 1$, так что мы можем выполнять все операции за $O(1)$, а затем в конце дважды насчитать массив префиксных сумм, вернувшись к исходному массиву.
```cpp
vector<int> precalc(vector<int> b) {
    b.insert(b.begin(), 0);
    b.insert(b.begin(), 0); // add two leading zeros
    vector<int> a = findDiffsArray(findDiffsArray(b));
    return a;
}

// [l, r) += [step, 2 * step, ..., (r - l) * step]
void addArithmOnHalfInterval(int l, int r, int step) {
    a[l] += step;
    if (r < n) {
        a[r] -= (r - l + 1) * step;
    }
    if (r + 1 < n) {
        a[r + 1] += (r - l) * step;
    }
}

vector<int> postcalc(vector<int>& a) {
    vector<int> finalB = findPrefixSums(findPrefixSums(a));
    finalB.erase(finalB.begin());
    finalB.erase(finalB.begin()); // delete leading zeros
    return finalB;
}
```
### Упражнение

Попробуйте решить последнюю задачу, если первый член арифметической прогрессии не совпадает с шагом, то есть на полуинтервале прибавляются числа $start, start + step, start + 2 \cdot step, \ldots, start + \left(r - l - 1\right) \cdot step$.

### Упражнение

Как обобщить решение прошлой задачи на случай, когда на отрезке прибавляется не линейная, а квадратичная функция? То есть прибавляются числа $step, 4 \cdot step, 9 \cdot step, \ldots, (r - l)^2 \cdot step$.

### Упражнение

Представьте, что у вас есть список операций виде «прибавить на полуинтервале $[l, r)$ значение $d$». Но вам нужно выполнять не эти операции, а целые отрезки операций! То есть в действительности операция имеет вид «примените к массиву операции с номерами от $L$-й до $R$-й». В конце нужно вывести получивщийся массив. Как решать такую задачу за $O(n + q)$?

### Замечание

Если вы знаете основы матанализа, можно легко понять, почему мы производили именно такие манипуляции. Ведь если взять производную, то прибавление константы на отрезке превратится в прибавление тождественного нуля, а для линейной функции нужно взять вторую производную.

### Двумерный разностный массив

### Задача

Дан двумерный массив размера $n \times m$, изначально состоящий из всех нулей. Приходит $q$ запросов прибавления константы на прямоугольнике. В конце нужно вывести элементы получившегося массива.

### Решение

Это двумерная версия задачи, которую мы рассматривали ранее, но для простоты изначальный массив состоит из нулей, поэтому нам не нужно переходить к разностному массиву. Надо подумать, к каким элементам что надо прибавить на разностном массиве, чтобы на исходном массиве прибавить $d$ на полупрямоугольнике $[lx, rx) \times [ly, ry)$.

Можно заметить, что если в разностном массиве к какому-то элементу прибавить $d$, то в исходном массиве $d$ прибавится ко всем элементам на суффиксном подпрямоугольнике.



Теперь перед нами стоит задача «прибавить на подпрямоугольнике через прибавления на суффиксных подпрямоугольниках». Эта задача аналогична задаче поиска суммы на подпрямоугольнике.



Прибавляем мы к тем же самым клеткам, сумму которых мы брали в задаче поиска суммы на подпрямоугольнике.

В конце мы возьмем префиксные суммы получившегося двумерного массива, и это и будет ответом.
```cpp
// [lx, rx) * [ly, ry) += d
void addOnHalfRectangle (int lx, int ly, int rx, int ry, int d) {
    diffs[lx][ly] += d;
    if (ry < m) {
        diffs[lx][ry] -= d;
    }
    if (rx < n) {
        diffs[rx][ly] -= d;
    }
    if (rx < n && ry < m) {
        diffs[rx][ry] += d;
    }
}

vector<vector<int>> postcalc(vector<vector<int>>& diffs) {
    vector<vector<int>> finalArr = findPrefixSums2D(diffs);
    finalArr.erase(finalArr.begin());
    // delete leading horizontal zeros
    for (size_t i = 0; i < finalArr.size(); i++) {
        finalArr[i].erase(finalArr[i].begin());
        // delete leading vertical zeros
    }
    return finalArr;
}
```
### Замечание

Как и раньше, мы добавляем нули в начало. В случае двумерного массива мы добавили строку и столбец нулей. В качестве упражнения остается проверить, что индексы, к которым надо прибавлять, будут именно такие. При этом как и в одномерном случае, правые индексы могут не существовать в массиве diffs, если они равны высоте или ширине изначального массива.

### Упражнение

Спросите себя: понимаете ли вы, что делать, если изначально массив состоит не из нулей?

### Упражнение

Как обобщить решение предыдущей задачи, если массив уже не двумерный, а трехмерный, и прибавлять надо на параллелепипеде?

### Определение

Строго говоря, разностный двумерный массив можно строить так же, как и одномерный. Формула для его элементов будет такая:

$$a_{i + 1, j + 1} = b_{i + 1, j + 1} - b_{i, j + 1} - b_{i + 1, j} + b_{i, j}$$ что похоже на аналогичную формулу для двумерных префиксных сумм. Но как вы видели, на практике нам не надо изначально строить разностный массив. Нужно просто изначально считать, что он заполнен нулями, а после выполнения операций по нему посчитать массив префиксных сумм. И начальные элементы добавить уже в самом конце.

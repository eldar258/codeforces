# Поиск суммы на отрезке и обобщение для других операций
Давайте сразу же применим префиксные суммы на примере задачи.
### Задача: поиск суммы на отрезке

Дан массив целых чисел, и приходят запросы вида «найти сумму на полуинтервале с позиции $l$ до позиции $r$». Нужно отвечать на запросы за $O(1)$.

### Решение

Давайте изначально перед ответами на запросы предпосчитаем массив префиксных сумм. Тогда если бы во всех запросах $l$ было равно нулю, то ответом на запрос была бы просто префиксная сумма $b_{r}$.

Но как же действовать, если $l \neq 0$? В префиксной сумме $b_{r}$ содержатся все нужные нам элементы, однако есть еще лишние: $a_0, a_1, \ldots, a_{l - 1}$. Но ведь сумма этих элементов — это как раз таки $b_l$. Таким образом, выполнено тождество:

$a_{l} + a_{l + 1} + \ldots + a_{r - 1} = b_{r} - b_{l}$

То есть для ответа на запрос поиска суммы на полуинтервале нужно просто вычесть друг из друга две предпосчитанные префиксные суммы.
```
int getSum(int left, int right) { // [left, right)
    return b[right] - b[left];
}
```
Обратите внимание на то, какие красивые формулы у нас получаются: сумма на полуинтервале $[l, r)$ — это $b_r - b_l$. Такая красота достигается именно благодаря тому, что мы используем полуинтервалы: и запросы у нас даны в виде полуинтервалов, и префиксные суммы. Если бы префиксные суммы были посчитаны в виде $b_i = a_0 + a_1 + \ldots + a_i$, то в формуле появились бы неприятные $\pm 1$, в которых легко запутаться: $b_r - b_{l - 1}$, и случай, когда $l = 0$, стал бы крайним, его надо было бы разбирать отдельно.

## Префиксные минимумы и ксоры

Давайте зададимся вопросом: для каких операций можно использовать префиксные суммы? Не только же для сложения? Какими свойствами должна обладать операция, чтобы можно было воспользоваться префиксными суммами?

На самом деле, необходимо, чтобы функция, которую мы считаем на отрезке, была обратима, что равносильно тому, что должна быть возможность по двум префиксам восстановить значение на отрезке. К примеру, операция суммы обратима, потому что если мы прибавили лишнее, потом это можно вычесть. А операции минимума и максимума необратимы. Нельзя по значениям минимумов на префиксах получить значение минимума на отрезке. К примеру, если элемент на позиции $0$ в массиве самый маленький, то все префиксные минимумы будут равны этому элементу, но минимумы на каких-то отрезках совсем с ним не связаны.



Но кроме суммы есть и другие операции, которые являются обратимыми. Одна из самых популярных — это, пожалуй, операция «побитового исключающего или», которая еще называется «xor» и обозначается $\oplus$.

При этом для xor'а пользоваться префиксными суммами еще удобнее. Выполнено тождество $x \oplus x = 0$ для любого числа $x$, что означает, что операция xor обратна сама себе, так что формула вычисления побитового исключающего или на отрезке получается такая:

$a_l \oplus a_{l + 1} \oplus \ldots \oplus a_{r - 1} = b_r \oplus b_l$

## Продвинутые применения

Давайте решим еще пару задач, в которых нам понадобятся префиксные суммы.

### Задача: подотрезок нулевой суммы

Дан массив. Необходимо за $O(n \log n)$ найти любой его непустой подотрезок с нулевой суммой элементов.

### Решение

Как мы уже знаем, суммы на отрезках — это разности префиксных сумм. Поэтому то, что сумма на отрезке равна нулю, равносильно тому, что префиксные суммы его концов равны.

Таким образом, мы свели задачу нахождения подотрезка нулевой суммы к задаче нахождения двух одинаковых элементов в массиве префиксных сумм. Для этого можно, к примеру, отсортировать массив префиксных сумм и искать совпадающие элементы среди соседних. Либо же можно воспользоваться хеш-таблицей (unordered_map в C++), и тогда асимптотика решения будет вовсе $O(n)$.

### Упражнение

Даны два массива одинаковой длины. Необходимо найти такой подотрезок, чтобы сумма элементов первого массива на этом подотрезке совпадала с суммой элементов второго массива на этом подотрезке. Асимптотика $O(n)$.

### Задача: кузнечик

Кузнечик находится в клетке с индексом $0$ и хочет попасть в клетку с индексом $n$. За один прыжок кузнечик может переместиться на любое количество клеток вперед, но при этом не меньше $l$ и не больше $r$. Найдите, сколько существует маршрутов кузнечика. Асимптотика $O(n)$.

### Решение

Задача очень похожа на стандартную задачу о кузнечике, однако в ней прыжки имели длину $1$ и $2$, а теперь у нас количество разных прыжков неограничено, поэтому такое же решение будет работать за $O(n \cdot (r - l))$, что в худшем случае будет $O(n^2)$.

Давайте внимательно посмотрим на формулу пересчета динамики. Количество способов попасть в клетку $i$ — это сумма количеств способов попасть во все предыдущие клетки на пути кузнечика: $dp_i = dp_{i - r} + dp_{i - r + 1} + \ldots + dp_{i - l - 1} + dp_{i - l}$

То есть элемент массива $dp$ определяется через сумму отрезка элементов того же массива. Давайте идти по позициям в порядке возрастания и не только насчитывать массив $dp$, но и его префиксные суммы. Тогда пересчет $dp_i$ через префиксные суммы будет работать за $O(1)$, а асимптотика всего алгоритма — $O(n)$.

Таким образом, мы видим, что в задачах необязательно предпосчитывать массив префиксных сумм заранее, он может строиться по ходу решения задачи и одновременно с этим использоваться.

## Меняющийся массив

Префиксные суммы очень удобны для подсчета суммы на отрезке в том случае, если массив в ходе запросов не меняется. Потому если какой-то элемент массива поменялся, то нужно пересчитать все префиксные суммы, в которые он входит. Это очень долго! Если есть запросы изменения, то лучше подойдут более продвинутые структуры данных: к примеру, дерево отрезков и дерево Фенвика.

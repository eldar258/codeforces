# Определение и построение
## Определение:
Префиксными суммами массива $[a_0, a_1, a_2, \ldots, a_{n - 1}]$называется массив $[b_0, b_1, b_2, \ldots, b_n]$, определяющийся следующим образом:

$b_0 = 0$

$b_1 = a_0$

$b_2 = a_0 + a_1$

$b_3 = a_0 + a_1 + a_2$

$\ldots$

$b_n = a_0 + a_1 + \ldots + a_{n - 1}$

## Сила полуинтервалов

Обратите внимание на то, что $b_i$— это сумма первых $i$элементов массива $a$. Иногда префиксные суммы определяют так, что $b_i = a_0 + a_1 + \ldots + a_i$, но этот способ неудобен на практике, в чем мы убедимся далее.

На данном примере можно познакомиться с очень важной концепцией в алгоритмах: практически всегда вместо отрезков лучше использовать полуинтервалы. К примеру, в данном случае $b_i$— это сумма элементов массива $a$на полуинтервале $[0, i)$, что на практике окажется удобнее, чем хранить в $b_i$сумму на отрезке $[0, i]$.

Также стоит помнить о том, что длина массива $b$на один больше длины массива $a$.

## Рекуррентная формула

Формулу для $b_i$можно записать рекурсивно:

$b_0 = 0$

$b_{i + 1} = b_{i} + a_{i}$для всех $i \ge 0$

Из рекуррентной формулы сразу становится ясно, как посчитать массив префиксных сумм за $O(n)$:
```
vector<int> findPrefixSums(vector<int>& a) {
    int n = a.size();
    vector<int> prefixSums(n + 1, 0);
    for (int i = 0; i < n; i++) {
        prefixSums[i + 1] = prefixSums[i] + a[i];
    }
    return prefixSums;
}
```
Обратите внимание, что элементы массива префиксных сумм — это суммы большого количества элементов исходного массива, поэтому будьте аккуратнее с переполнением. И вообще, на протяжении всей этой темы вы можете столкнуться с переполнением, поэтому будьте всегда начеку!

Кроме того, есть встроенная в C++ функция std::partial_sum, которая как раз таки считает префиксные суммы. Пример ее работы:
```
vector<int> arr = {1, 2, 3, 4, 5};
vector<int> prefixSums(n + 1, 0);
partial_sum(arr.begin(), arr.end(), prefixSums.begin() + 1);
for (int elem : prefixSums) {
    cout << elem << endl;
}
```
Обратите внимание, что сама функция partial_sum не оставляет нуля в начале, поэтому нам приходится делать это самим, добавляя единицу к prefixSums.begin().

## Способ визуализации

У нас уже есть две интуиции для понимания $b_i$: сумма первых $i$элементов исходного массива и сумма элементов исходного массива на полуинтервале $[0, i)$. Давайте посмотрим на еще один вариант того, как об этом можно думать. Можно представить, что элементы массива находятся в ячейках, а префиксные суммы находятся между ними — на перегородках. И содержат в себе суммы всего того, что находится перед этой перегородкой:

## Источник
Все материалы взяты из открытого источника https://codeforces.com/edu/course/3/lesson/10/1
